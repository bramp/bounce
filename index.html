<!DOCTYPE html>
<html>
<head>
    <!--script src="https://cdn.jsdelivr.net/npm/phaser@3.21.0/dist/phaser-arcade-physics.min.js"></script-->
    <script src="node_modules/phaser/dist/phaser-arcade-physics.js"></script>
</head>
<body>

    <script>
    var config = {
        type: Phaser.AUTO, // Phaser.CANVAS or Phaser.WEBGL
        width: 800,
        height: 600,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 300 },
                debug: true,
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var game = new Phaser.Game(config);

    var score = 0;
    var scoreText;
    var level = 1;

    const ballRadius = 5; // TODO Remove this global constant

    var shapes;
    var balls;

    // Returns true iff the point (x,y) lies inside the polygon.
    // The polygon is a array of points in the form [x0, y0, x1, y1, ..., x0, y0]
    // https://www.jeffreythompson.org/collision-detection/poly-point.php
    function pointOnPolygon(x, y, polygon)
    {
        let collision = false;

        for (var i = 3; i < polygon.length; i += 2) {
            let currentX = polygon[i - 3];
            let currentY = polygon[i - 2];

            let nextX = polygon[i - 1];
            let nextY = polygon[i];

            // https://www.jeffreythompson.org/collision-detection/poly-point.php
            if ( ((currentY > y) != (nextY > y)) && (x < (nextX-currentX) * (y-currentY) / (nextY-currentY) + currentX) ) {
              collision = !collision;
            }
        }

        return collision;
    }

    // https://www.jeffreythompson.org/collision-detection/poly-circle.php
    function circleOnPolygon(cx, cy, cr, polygon)
    {
        for (var i = 3; i < polygon.length; i += 2) {
            let currentX = polygon[i - 3];
            let currentY = polygon[i - 2];

            let nextX = polygon[i - 1];
            let nextY = polygon[i];

            // check for collision between the circle and
            // a line formed between the two vertices.
            let collision = circleOnLine(cx, cy, cr, currentX, currentY, nextX, nextY);
            if (collision) return true;
        }

        // the above algorithm only checks if the circle
        // is touching the edges of the polygon â€“ in most
        // cases this is enough, but the following also
        // test if the center of the circle is inside the
        // polygon.
        return pointOnPolygon(cx, cy, polygon);
    }

    // https://www.jeffreythompson.org/collision-detection/line-circle.php
    function circleOnLine(cx, cy, cr, x1, y1, x2, y2) {
      // is either end INSIDE the circle?
      // if so, return true immediately
      const inside1 = pointOnCircle(x1, y1, cx, cy, cr);
      const inside2 = pointOnCircle(x2, y2, cx, cy, cr);
      if (inside1 || inside2) return true;

      // get length of the line
      const len = Phaser.Math.Distance.Between(x1, y1, x2, y2);

      // get dot product of the line and circle
      const dot = ( ((cx-x1)*(x2-x1)) + ((cy-y1)*(y2-y1)) ) / (len * len);

      // find the closest point on the line
      const closestX = x1 + (dot * (x2-x1));
      const closestY = y1 + (dot * (y2-y1));

      // is this point actually on the line segment?
      // if so keep going, but if not, return false
      const onSegment = pointOnLine(closestX, closestY, x1, y1, x2, y2);
      if (!onSegment) return false;

      // get distance to closest point
      const distance = Phaser.Math.Distance.Between(closestX, closestY, cx, cy);

      // is the circle on the line?
      return distance <= cr;
    }

    // https://www.jeffreythompson.org/collision-detection/line-point.php
    function pointOnLine(x, y, x1, y1, x2, y2) {
      // get distance from the point to the two ends of the line
      const d1 = Phaser.Math.Distance.Between(x, y, x1, y1);
      const d2 = Phaser.Math.Distance.Between(x, y, x2, y2);

      // get the length of the line
      const lineLen = Phaser.Math.Distance.Between(x1, y1, x2, y2);

      return Math.abs(d1 + d2 - lineLen) < Number.EPSILON;
    }

    // https://www.jeffreythompson.org/collision-detection/point-circle.php
    function pointOnCircle(x, y, cx, cy, cr) {
      const dX = x - cx;
      const dY = y - cy;

      return (dX * dX) + (dY * dY) <= (cr * cr);
    }

    //class Ball extends Phaser.GameObjects.Sprite {
    class Ball extends Phaser.Physics.Arcade.Sprite {
        constructor (scene, x, y) {
            super(scene, x, y, 'ball');

            this.radius = ballRadius;
        }
    }

    class Shape extends Phaser.GameObjects.Container {
        static color(lives) {
            if(lives <= 0) {
                return 0x000000;
            }

            return Shape.colors[((lives-1) * 30) % Shape.colors.length].color;
        }

        static calcPoints(rotation, sides, radius) {
            console.assert(sides >= 3, sides);
            console.assert(radius >= 1, radius);

            // Create all the points for the edge of the polygon.
            var points = [];
            var xmin = 0;
            var ymin = 0;
            for (var i = 0; i < sides; i++) {
                const angle = i * Math.PI * 2 / sides + rotation;
                var x = Math.sin(angle) * radius;
                var y = Math.cos(angle) * radius;

                if (x < xmin) {
                    xmin = x;
                }
                if (y < ymin) {
                    ymin = y;
                }

                points.push([x, y]);
            }

            // Adjust to ensure 0,0 is top left.
            for (var i = 0; i < points.length; i++) {
                points[i][0] -= xmin;
                points[i][1] -= ymin;
            }
            return points;
        }

        constructor (scene, x, y, rotation, sides, lives, radius) {
            super(scene, x, y);

            var shape = new Phaser.GameObjects.Polygon(scene, 0, 0, 
                    Shape.calcPoints(rotation, sides, radius),
                    Shape.color(lives));
            this.add(shape);

            var text = new Phaser.GameObjects.Text(scene,
                -8, -16,
                lives,
                {
                    fontSize: '32px',
                    fill: '#000',
                    align: 'center',
                }
            );
            text.setDepth(1);
            this.add(text);

            this.setSize(shape.width, shape.height);

            this.shape = shape;
            this.text = text;
            this.lives = lives;

            this.pathData = shape.pathData;
        }

        setLives(lives) {
            this.lives = lives;
            this.text.setText(lives);
            this.shape.setFillStyle(Shape.color(lives));
        }
    }
    Shape.colors = Phaser.Display.Color.HSVColorWheel();

    function preload ()
    {
        // Draw the ball
        graphics = this.add.graphics(0, 0);
        graphics.fillStyle(0xFFFFFF, 1.0);
        graphics.fillCircle(ballRadius, ballRadius, ballRadius);
        graphics.generateTexture('ball', ballRadius*2, ballRadius*2);
        graphics.destroy();
    }

    function create ()
    {
        shapeRadius = 50;

        shapes = this.physics.add.group({
            immovable: true,
            allowGravity: false,
            allowRotation: false,
            allowDrag: false,
        });

        for (var x = shapeRadius; x < config.width;) {
            var sides = Phaser.Math.Between(3, 5)
            var rotation = Phaser.Math.FloatBetween(0, 2 * Math.PI)
            var strength = Phaser.Math.Between(1, 3);
            var shape = new Shape(this, x, 500, rotation, sides, strength, shapeRadius);
            shapes.add(shape, true);

            x += Phaser.Math.FloatBetween(2, 3) * shapeRadius;
        }

        balls = this.physics.add.group({
            collideWorldBounds: true,
            dragX: 1, dragY: 1,
            bounceX: 0.9, bounceY: 0.9,
            velocityX: 200,

            //allowGravity: false,
            //allowRotation: false,
            //allowDrag: false,
        });
        let ball = new Ball(this, 50, 100);
        balls.add(ball, true);

        ball.body.customSeparateX = true;
        ball.body.customSeparateY = true;

        this.physics.add.collider(shapes, balls, shapeHit, shapeCollider);

        /*
        scoreText = this.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });
        cursors = this.input.keyboard.createCursorKeys();
        */

        this.input.on('pointermove', function (pointer) {
            ball.setPosition(pointer.x, pointer.y);
        });
    }

    // The shape and the ball hit
    function shapeHit (shape, ball)
    {
        console.log("shapeHit", shapes.countActive());

        shape.setLives(shape.lives - 1);
        if (shape.lives <= 0) {
            shapes.remove(shape);
            shapes.killAndHide(shape);
        }

        // TODO Bounce the ball
    }

    // More complex shape collider, to support arbitrary shapes.
    function shapeCollider(shape, ball)
    {
        if (!shape.active) {
            // TODO Is this a bug, that the Collider is called on inactive objects?
            return false;
        }

        // Translate the ball to the shape's origin
        const ballX = ball.x - shape.x + shape.width * shape.originX;
        const ballY = ball.y - shape.y + shape.height * shape.originY;

        //return pointOnPolygon(ballX, ballY, shape.pathData);
        let ret = circleOnPolygon(ballX, ballY, ball.radius, shape.pathData);
        console.log("shapeCollider", ballX, ballY, ret);
        if (ret) {
            debugger;
        }
        return ret
    }

    function update ()
    {

    }
    </script>

</body>
</html>